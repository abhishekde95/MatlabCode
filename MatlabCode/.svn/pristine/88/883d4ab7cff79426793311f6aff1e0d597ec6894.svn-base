function [response] = ComputeNakaRushtonJPW(params,stimuli,surftype)% Compute the Naka-Rushton function on passed stimuli.% Several different forms may be computed depending on lenght of% passed params vector.  For now, read the code to see.% % 8/1/05    dhb, pr     Wrote from FitLightnessOrient version% 8/2/07    dhb         Rewrote to allow several different forms depending%                       on length of params.% 12/13/11  gdlh        Changed to work with neural data% 6/27/12   gdlh        Adding more elaborate fits (surface1)% 11/21/12  JPW         Adding more elaborate fits (surface2)% 6/12/13   JPW         Adding surface 3% 5/14      JPW         New surface paradigm. This is the new surf3% 5/14      JPW         Added surface 4% 6/14      JPW         Added surface 5% 8/14      JPW         Cleaning up a bit. Deleted Surfs 1 and 2.  Added surface 6.% 11/14     JPW         Adding surfaces 7 and 8% 8/15      JPW         Adding fit for negative binomal surface% 11/16     JPW         Adding surfaces 9 - 12if (nargin < 3)    surftype = 'undeclared';end% Initialize some conserved parametersresponse =  nan(size(stimuli,1),1);% Fit requested surfaceif strcmp(surftype, 'symmetric')    % symmetric: 1D line, only accepts vector as input        % Assign parameter values    sig = params(2);    exp = params(3);    bl = params(4);    A= params(1) - bl;        % Generate responses    response = A * abs(stimuli).^exp ./ (abs(stimuli).^exp + sig.^exp) + bl;elseif strcmp(surftype, 'asymmetric')    % asymmetric: 1D line, allows for 2 NakaRushtons tail to tail. Baseline    % is shared, but other params are independent.        % Assign parameter values    sig1 = params(3);    sig2 = params(4);    exp1 = params(5);    exp2 = params(6);    bl = params(7);    A1 = params(1) - bl;    A2 = params(2) - bl;        % Generate responses    L = stimuli > 0;     response(L) = A1 * abs(stimuli(L)).^exp1 ./ (abs(stimuli(L)).^exp1 + sig1.^exp1) + bl;    response(~L) = A2 * abs(stimuli(~L)).^exp2 ./ (abs(stimuli(~L)).^exp2 + sig2.^exp2) + bl;    elseif strcmp(surftype, 'surface7')    % Same as surface 6, but exponent is a singular value.    % Adding suppression. Sigma is c50, and sign of c50 designates    % excitation or suppression.        % Assign parameters    sig1 = params(2);    sig2 = params(3);    exp = params(4);    bl = params(5);    A = params(1) - bl;    rot = params(6);        % Unpack stimuli    rotMat = [cos(rot) sin(rot); -sin(rot) cos(rot)];    tempRotPts = (rotMat * [stimuli(:,1) stimuli(:,2)]')';    contrast = tempRotPts(:,1);    posIdx = contrast >= 0;    poscon = contrast(posIdx);    negcon = abs(contrast(~posIdx));    % Generate repsonses    response(posIdx) = (A * poscon.^exp) ./ (poscon.^exp + sig1.^exp) + bl;    %response(~posIdx) = (A * negcon.^exp) ./ (negcon.^exp + sig2.^exp) + bl;    if sig2 > 0        response(~posIdx) = (A * negcon.^exp) ./ (negcon.^exp + sig2.^exp) + bl;    else        response(~posIdx) = -(bl * negcon.^exp) ./ (negcon.^exp + abs(sig2).^exp) + bl;    end    elseif strcmp(surftype, 'surface8')     % Surf8: nonlinear 2D surface. All parameters are shared except for    % c50s along each axis.  c50s change smoothly with angle, as the major    % and minor axes of an ellipse.    % r(theta) = sqrt((a*sin(theta)).^2 + (b*cos(theta)).^2))        % Assign parameter values    sig1 = params(2);    sig2 = params(3);    sig3 = params(4);    sig4 = params(5);    exp = params(6);    bl = params(7);    A = params(1) - bl;    rot = params(8);        % Unpack stimuli    rotMat = [cos(rot) sin(rot); -sin(rot) cos(rot)];    tempRotPts = (rotMat * [stimuli(:,1) stimuli(:,2)]')';    [theta,rho] = cart2pol(tempRotPts(:,1),tempRotPts(:,2));        % Calclulate all of the possible sigma values for each quadrant     sigmasQ1 = (sig1*sig2) ./ (abs((sig1*sin(theta)).^2) + abs((sig2*cos(theta)).^2)).^(1/2);    sigmasQ2 = (sig2*sig3) ./ (abs((sig2*cos(theta)).^2) + abs((sig3*sin(theta)).^2)).^(1/2);    sigmasQ3 = (sig3*sig4) ./ (abs((sig3*sin(theta)).^2) + abs((sig4*cos(theta)).^2)).^(1/2);    sigmasQ4 = (sig4*sig1) ./ (abs((sig4*cos(theta)).^2) + abs((sig1*sin(theta)).^2)).^(1/2);        % Assign sigma values based on quadrant    sig = nan(size(response));    for n = 1:numel(theta)        if theta(n) > pi/2            sig(n) = sigmasQ3(n);        elseif theta(n) > 0 && theta(n) <= pi/2            sig(n) = sigmasQ4(n);        elseif theta(n) <= 0 && theta(n) > -pi/2            sig(n) = sigmasQ1(n);        elseif theta(n) <= -pi/2            sig(n) = sigmasQ2(n);        end            end        % Generate responses    response = A * rho.^exp ./ (rho.^exp + sig.^exp) + bl;    elseif strcmp(surftype,'conicsection_rt') || strcmp(surftype,'conicsection')    % Building a surface whose c50 changes as a conic section.    % *sig1 controls the preferred direction c50.    % *sig2 controls the anti-preferred c50. Negative value is suppression.    % c50 is sent in as reciprocal so that the variable can be contrinuous.     % *orthosig is the orthogonal axis. Constrained to be symmetrical.    % Positive values are the minor axis of ellipse. Negative values are    % width of the curved hyperbola at the focus. Reciprocal of c50 is sent    % in so that values can be continuous. If orth = Inf, surface is 1D.        % Assign parameter values    sig1 = 1/params(2);    sig2 = 1/params(3);    orthosig = params(4); % converted to reciprocal below    exp = params(5);    bl = params(6);    A = params(1)-bl;    rot = params(7);        % Unpack stimuli    rotMat = [cos(rot) sin(rot); -sin(rot) cos(rot)];    tempRotPts = (rotMat * stimuli')';    x = tempRotPts(:,1);    y = tempRotPts(:,2);    posIdx = x >= 0;    [theta,rho] = cart2pol(x,y);    theta = abs(theta);        % Calclulate all of the possible sigma values for each quadrant     % r(theta) = (a*b) ./ sqrt((a*sin(theta)).^2 +/- (b*cos(theata)).^2))    sig = nan(size(theta));        % Positive contrast    if orthosig > 0 % ellipse        nom = sig1 * 1/orthosig;        denom = (sig1*sin(theta(posIdx))).^2 + (1/orthosig*cos(theta(posIdx))).^2;        sig(posIdx) = nom ./ sqrt(denom);    elseif orthosig < 0 % hypoerbola        % there is a sign switch and half rectification here.        nom = sig1 * abs(1/orthosig);        denom = abs(min(0,(sig1*sin(theta(posIdx))).^2 - (1/orthosig*cos(theta(posIdx))).^2));        sig(posIdx) = nom ./ sqrt(denom);    else % 1D naka rushton        %sig(posIdx) = sqrt(sig1^2 ./ (cos(theta(posIdx))).^2);        sig(posIdx) = sig1 ./ cos(theta(posIdx));    end        % Negative contrast    if orthosig > 0 % ellipse        if sig2 == Inf            sig(~posIdx) = (1/orthosig) ./ sin(theta(~posIdx));        else            nom = sig2 * 1/orthosig;            denom = (sig2*sin(theta(~posIdx))).^2 + (1/orthosig*cos(theta(~posIdx))).^2;            sig(~posIdx) = nom ./ sqrt(denom);        end    elseif orthosig < 0 % hypoerbola        % there is a sign switch and half rectification here.        nom = sig2 * abs(1/orthosig);        denom = abs(min(0,(sig2*sin(theta(~posIdx))).^2 - (1/orthosig*cos(theta(~posIdx))).^2));         sig(~posIdx) = nom ./ sqrt(denom);    else % 1D naka rushton                sig(~posIdx) = abs(sig2 ./ cos(theta(~posIdx)));    end        response = A * rho.^exp ./ (rho.^exp + sig.^exp) + bl;    elseif strcmp(surftype,'conicsection_xy') || strcmp(surftype,'conicsection2')        % An alternative parameterization of 'conicsection'.        % Assign parameter values    sig1 = (1/params(2));    sig2 = (1/params(3));    orthosig = (params(4)); % converted to reciprocal below    exp = params(5);    bl = params(6);    A = params(1)-bl;    rot = params(7);            % Rotate axes such that the x-axis is the principle axis.    rotMat = [cos(rot) sin(rot); -sin(rot) cos(rot)];    tempRotPts = (rotMat * stimuli')';    x = tempRotPts(:,1);    y = tempRotPts(:,2);     y = abs(y);    posIdx = x >= 0;        % Convert 2D stim (rho,theta) into 1D stim (effective contrast)    effcont = nan(size(x));        if orthosig > 0 % ellipse        effcont(posIdx) = sqrt(x(posIdx).^2 + (y(posIdx)./(1/orthosig/sig1)).^2);        if sig2 == Inf            effcont(~posIdx) = abs(y(~posIdx)./(1/orthosig/sig1));        else            effcont(~posIdx) = sqrt((x(~posIdx)/(sig2/sig1)).^2 + (y(~posIdx)./(1/orthosig/sig1)).^2);        end    elseif orthosig < 0 % hypoerbola        effcont(posIdx) = sqrt(max(x(posIdx).^2 - (y(posIdx)./(1/abs(orthosig)/sig1)).^2,0));        if sig2 == Inf            effcont(~posIdx) = x(~posIdx)./(sig2/sig1);        else            effcont(~posIdx) = sqrt(max((x(~posIdx)./(sig2/sig1)).^2 - (y(~posIdx)./(1/abs(orthosig)/sig1)).^2,0));        end        %effcont = (max(effcont,0));    else % 1D naka rushton        effcont(posIdx) = x(posIdx);        effcont(~posIdx) = abs(x(~posIdx)./(sig2/sig1));    end    if any(effcont<0)        disp('negative effcont on non-hyperbola')        keyboard        effcont = max(effcont,0);    end    response = A * effcont.^exp ./ (effcont.^exp + sig1.^exp) + bl;    elseif strcmp(surftype,'conicsection_sym')        % An symmetric version of 'conicsection'.    % Building a surface whose c50 changes as a conic section.    % *sig1 controls the preferred direction c50.    % *sig2 controls rectification (1=full, 0=half)    % *orthosig is the c50 along the orthogonal axis. Constrained to be symmetrical.    % Positive values are the minor axis of ellipse. Negative values are    % width of the curved hyperbola at the focus. Reciprocal of c50 is sent    % in so that values can be continuous. If orth = Inf, surface is 1D.            % Assign parameter values    sig1 = params(2); % asymmetric axis c50    sig2 = params(3); % binary (0 or 1) that makes PD half or full rectified    orthosig = (1/params(4)); % symmetric axis c50 (input is reciprocal of c50)    %sig2 = 0;    %orthosig = Inf;    exp = params(5);    bl = params(6);    A = params(1)-bl;    rot = params(7);            % Rotate axes such that the x-axis is the principle axis.    rotMat = [cos(rot) sin(rot); -sin(rot) cos(rot)];    tempRotPts = (rotMat * stimuli')';    x = tempRotPts(:,1);    y = tempRotPts(:,2);     %y = abs(y);    %posIdx = x >= 0;        % Convert 2D stim (rho,theta) into 1D stim (effective contrast)    %effcont = nan(size(x));        effcont = max(x,0).^2 + sig2 * x.^2 + 1/orthosig * sig1 * y.^2;%     if orthosig > 1 % ellipse%         effcont = sqrt(x.^2 + 1/orthosig/sig1 * y.^2); %fully rectified%         if sig2 == 0 % half rectified%             effcont(~posIdx) = abs(y(~posIdx)./(1/orthosig/sig1));%         end%             %     elseif orthosig < 0 % hypoerbola%         effcont = sqrt(max(x.^2 - (y./(1/abs(orthosig)/sig1)).^2,0));%         if sig2 == Inf%             effcont(~posIdx) = x(~posIdx)./(sig2/sig1);%         else%             effcont(~posIdx) = sqrt(max((x(~posIdx)./(sig2/sig1)).^2 - (y(~posIdx)./(1/abs(orthosig)/sig1)).^2,0));%         end%         %effcont = (max(effcont,0));%     else % 1D naka rushton%         effcont(posIdx) = x(posIdx);%         effcont(~posIdx) = abs(x(~posIdx)./(sig2/sig1));%     end    if any(effcont<0)        disp('negative effcont values...')        effcont = max(effcont,0);    end    response = A * effcont.^exp ./ (effcont.^exp + sig1.^exp) + bl;        else    error('Must specify desired fit.');    keyboardend